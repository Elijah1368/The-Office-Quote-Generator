{"ast":null,"code":"import { FETCH_QUOTES, NEW_QUOTE } from '../constants';\nexport const fetchQuotes = (...urls) => dispatch => {\n  let promises = [];\n\n  for (let url of urls) {\n    promises.push(asyncFetch(url));\n  }\n\n  Promise.all(promises).then(results => {\n    let payload = results.reduce((accumulator, val) => Object.assign(accumulator, val));\n    return {\n      type: FETCH_QUOTES,\n      payload\n    };\n  });\n};\n\nfunction asyncFetch(url) {\n  fetch(url).then(response => {\n    if (!response.ok) {\n      throw Error(response.statusText);\n    }\n\n    return response.json();\n  }).then(data => {\n    console.log(addQuotes({}, data));\n    return addQuotes({}, data);\n  }).catch(error => {\n    console.log(error);\n  });\n}\n\nexport const newQuote = name => {\n  return {\n    type: NEW_QUOTE\n  };\n};\n\nfunction addQuotes(container, quotes) {\n  let result = {\n    container\n  };\n  quotes.map(quote => {\n    let key = nameOrCharacter(quote);\n\n    if (result.hasOwnProperty(quote[key])) {\n      result[quote[key]].push(quote.quote);\n    } else {\n      result[quote[key]] = [quote.quote];\n    }\n  });\n  return result;\n}\n\nfunction nameOrCharacter(quote) {\n  if (quote.hasOwnProperty('name')) {\n    return 'name';\n  } else {\n    return 'character';\n  }\n}","map":{"version":3,"sources":["C:/Users/Elija/Projects/quote-generator/random-quote-generator/src/actions/index.js"],"names":["FETCH_QUOTES","NEW_QUOTE","fetchQuotes","urls","dispatch","promises","url","push","asyncFetch","Promise","all","then","results","payload","reduce","accumulator","val","Object","assign","type","fetch","response","ok","Error","statusText","json","data","console","log","addQuotes","catch","error","newQuote","name","container","quotes","result","map","quote","key","nameOrCharacter","hasOwnProperty"],"mappings":"AAAA,SAAQA,YAAR,EAAsBC,SAAtB,QAAsC,cAAtC;AAGA,OAAO,MAAMC,WAAW,GAAG,CAAC,GAAGC,IAAJ,KAAaC,QAAQ,IAAI;AAChD,MAAIC,QAAQ,GAAG,EAAf;;AACA,OAAK,IAAIC,GAAT,IAAgBH,IAAhB,EAAqB;AACjBE,IAAAA,QAAQ,CAACE,IAAT,CAAcC,UAAU,CAACF,GAAD,CAAxB;AACH;;AAEDG,EAAAA,OAAO,CAACC,GAAR,CAAYL,QAAZ,EAAsBM,IAAtB,CAA4BC,OAAD,IAAY;AACnC,QAAIC,OAAO,GAAGD,OAAO,CAACE,MAAR,CAAe,CAACC,WAAD,EAAcC,GAAd,KAAsBC,MAAM,CAACC,MAAP,CAAcH,WAAd,EAA2BC,GAA3B,CAArC,CAAd;AACA,WAAO;AAACG,MAAAA,IAAI,EAAEnB,YAAP;AAAqBa,MAAAA;AAArB,KAAP;AACH,GAHD;AAIH,CAVM;;AAYP,SAASL,UAAT,CAAoBF,GAApB,EAAwB;AACpBc,EAAAA,KAAK,CAACd,GAAD,CAAL,CACCK,IADD,CACMU,QAAQ,IAAI;AACd,QAAI,CAACA,QAAQ,CAACC,EAAd,EAAiB;AACb,YAAMC,KAAK,CAACF,QAAQ,CAACG,UAAV,CAAX;AACH;;AACD,WAAOH,QAAQ,CAACI,IAAT,EAAP;AACH,GAND,EAOCd,IAPD,CAOMe,IAAI,IAAI;AACVC,IAAAA,OAAO,CAACC,GAAR,CAAYC,SAAS,CAAC,EAAD,EAAKH,IAAL,CAArB;AACA,WAAOG,SAAS,CAAC,EAAD,EAAKH,IAAL,CAAhB;AACH,GAVD,EAWCI,KAXD,CAWOC,KAAK,IAAG;AACXJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACH,GAbD;AAcH;;AAED,OAAO,MAAMC,QAAQ,GAAIC,IAAD,IAAU;AAC9B,SAAO;AACHd,IAAAA,IAAI,EAAElB;AADH,GAAP;AAGH,CAJM;;AAMP,SAAS4B,SAAT,CAAmBK,SAAnB,EAA8BC,MAA9B,EAAqC;AACjC,MAAIC,MAAM,GAAG;AAACF,IAAAA;AAAD,GAAb;AACAC,EAAAA,MAAM,CAACE,GAAP,CAAWC,KAAK,IAAI;AAChB,QAAIC,GAAG,GAAGC,eAAe,CAACF,KAAD,CAAzB;;AACA,QAAIF,MAAM,CAACK,cAAP,CAAsBH,KAAK,CAACC,GAAD,CAA3B,CAAJ,EAAsC;AAClCH,MAAAA,MAAM,CAACE,KAAK,CAACC,GAAD,CAAN,CAAN,CAAmBhC,IAAnB,CAAwB+B,KAAK,CAACA,KAA9B;AACH,KAFD,MAEO;AACHF,MAAAA,MAAM,CAACE,KAAK,CAACC,GAAD,CAAN,CAAN,GAAqB,CAACD,KAAK,CAACA,KAAP,CAArB;AACH;AACJ,GAPD;AASA,SAAOF,MAAP;AACH;;AAED,SAASI,eAAT,CAAyBF,KAAzB,EAA+B;AAC3B,MAAIA,KAAK,CAACG,cAAN,CAAqB,MAArB,CAAJ,EAAiC;AAC7B,WAAO,MAAP;AACH,GAFD,MAEO;AACH,WAAO,WAAP;AACH;AACJ","sourcesContent":["import {FETCH_QUOTES, NEW_QUOTE} from '../constants';\r\n\r\n\r\nexport const fetchQuotes = (...urls) => dispatch => {\r\n    let promises = [];\r\n    for (let url of urls){\r\n        promises.push(asyncFetch(url));\r\n    }\r\n\r\n    Promise.all(promises).then((results) =>{\r\n        let payload = results.reduce((accumulator, val) => Object.assign(accumulator, val));\r\n        return {type: FETCH_QUOTES, payload};\r\n    })\r\n};\r\n\r\nfunction asyncFetch(url){\r\n    fetch(url)\r\n    .then(response => {\r\n        if (!response.ok){\r\n            throw Error(response.statusText);\r\n        }\r\n        return response.json();\r\n    })\r\n    .then(data => {\r\n        console.log(addQuotes({}, data));\r\n        return addQuotes({}, data);\r\n    })\r\n    .catch(error=> {\r\n        console.log(error);\r\n    })\r\n}\r\n\r\nexport const newQuote = (name) => {\r\n    return {\r\n        type: NEW_QUOTE\r\n    }\r\n};\r\n\r\nfunction addQuotes(container, quotes){\r\n    let result = {container};\r\n    quotes.map(quote => {\r\n        let key = nameOrCharacter(quote);\r\n        if (result.hasOwnProperty(quote[key])){\r\n            result[quote[key]].push(quote.quote);\r\n        } else {\r\n            result[quote[key]] = [quote.quote];\r\n        }\r\n    });\r\n\r\n    return result\r\n}\r\n\r\nfunction nameOrCharacter(quote){\r\n    if (quote.hasOwnProperty('name')){\r\n        return 'name';\r\n    } else {\r\n        return 'character';\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}